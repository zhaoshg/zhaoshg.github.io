<!doctype html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />






  <link rel="alternate" href="/atom.xml" title="荆棘之路" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="导读正则表达式是什么？有什么用？正则表达式(Regular Expression)是一种文本规则，可以用来校验、查找、替换与规则匹配的文本。又爱又恨的正则正则表达式是一个强大的文本匹配工具，但是它的规则实在很繁琐，而且理解起来也颇为蛋疼，容易让人望而生畏。如何学习正则刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。">
<meta name="keywords" content="转载,正则,正则表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="Java正则速成秘籍（二）之心法篇">
<meta property="og:url" content="http://www.javacn.top/20170421/regular_java_2/index.html">
<meta property="og:site_name" content="荆棘之路">
<meta property="og:description" content="导读正则表达式是什么？有什么用？正则表达式(Regular Expression)是一种文本规则，可以用来校验、查找、替换与规则匹配的文本。又爱又恨的正则正则表达式是一个强大的文本匹配工具，但是它的规则实在很繁琐，而且理解起来也颇为蛋疼，容易让人望而生畏。如何学习正则刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。">
<meta property="og:updated_time" content="2017-05-03T03:18:30.547Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java正则速成秘籍（二）之心法篇">
<meta name="twitter:description" content="导读正则表达式是什么？有什么用？正则表达式(Regular Expression)是一种文本规则，可以用来校验、查找、替换与规则匹配的文本。又爱又恨的正则正则表达式是一个强大的文本匹配工具，但是它的规则实在很繁琐，而且理解起来也颇为蛋疼，容易让人望而生畏。如何学习正则刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.javacn.top/20170421/regular_java_2/"/>





  <title> Java正则速成秘籍（二）之心法篇 | 荆棘之路 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-98173663-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0a667b2d82398abb1dcb34b2b09ca44a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">荆棘之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just Do It !</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.javacn.top/20170421/regular_java_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="曙光">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="荆棘之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java正则速成秘籍（二）之心法篇
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-21T16:47:07+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/正则/" itemprop="url" rel="index">
                    <span itemprop="name">正则</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/20170421/regular_java_2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/20170421/regular_java_2/" class="leancloud_visitors" data-flag-title="Java正则速成秘籍（二）之心法篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  6,502
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p><strong>正则表达式是什么？有什么用？</strong><br>正则表达式(Regular Expression)是一种文本规则，可以用来校验、查找、替换与规则匹配的文本。<br><strong>又爱又恨的正则</strong><br>正则表达式是一个强大的文本匹配工具，但是它的规则实在很繁琐，而且理解起来也颇为蛋疼，容易让人望而生畏。<br><strong>如何学习正则</strong><br>刚接触正则时，我看了一堆正则的语义说明，但是仍然不明所以。后来，我多接触一些正则的应用实例，渐渐有了感觉，再结合语义说明，终有领悟。我觉得正则表达式和武侠修练武功差不多，应该先练招式，再练心法。如果一开始就直接看正则的规则，保证你会懵逼。<br>当你熟悉基本招式（正则基本使用案例）后，也该修炼修炼心法（正则语法）了。真正的高手不能只靠死记硬背那么几招把式。就像张三丰教张无忌太极拳一样，领悟心法，融会贯通，少侠你就可以无招胜有招，成为传说中的绝世高手。</p>
<p><strong>以上闲话可归纳为一句：学习正则应该从实例去理解规则。</strong></p>
<a id="more"></a>
<p>打开秘籍：欲练神功，必先自宫！没有蛋，也就不会蛋疼了。<br><strong>Java正则速成秘籍分三篇：</strong>  </p>
<ul>
<li><a href="../Java正则速成秘籍（一）之招式篇">Java正则速成秘籍（一）之招式篇</a><br>展示Java对于正则表达式的支持。</li>
<li><a href="#">Java正则速成秘籍（二）之心法篇</a><br>介绍正则表达式的语法规则。</li>
<li><a href="../Java正则速成秘籍（三）之见招拆招篇">Java正则速成秘籍（三）之见招拆招篇</a><br>从实战出发，介绍正则的常用案例。<br>在 <a href="../Java正则速成秘籍（一）之招式篇">Java正则速成秘籍（一）之招式篇</a> 一文，我们学习了Java支持正则功能的API。<br>本文是Java正则速成秘籍的心法篇。主要介绍正则表达式的语法规则。正则语法规则是一种标准，主流开发语言对于正则语法的支持大体相同。<br>分组构造、贪婪与懒惰属于正则表达式中较为复杂的应用，建议理解完基本元字符后再去了解。<br>本文案例中使用的<code>checkMatches</code>、<code>findAll</code>方法请见附录。   </li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了理解下面章节的内容，你需要先了解一些基本概念。</p>
<p><strong>正则表达式</strong></p>
<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<p><strong>元字符</strong><br>元字符(metacharacters)就是正则表达式中具有特殊意义的专用字符。</p>
<p><strong>普通字符</strong><br>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><h2 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h2><p>正则表达式的元字符难以记忆，很大程度上是因为有很多为了简化表达而出现的等价字符。<br>而实际上最基本的元字符，并没有那么多。对于大部分的场景，基本元字符都可以搞定。<br>让我们从一个个实例出发，由浅入深的去体会正则的奥妙。</p>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选 - |"></a>多选 - <code>|</code></h3><p><strong><em>例 匹配一个确定的字符串</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">checkMatches(<span class="string">"abc"</span>, <span class="string">"abc"</span>);</div></pre></td></tr></table></figure></p>
<p>如果要匹配一个确定的字符串，非常简单，如例1所示。<br>如果你不确定要匹配的字符串，希望有多个选择，怎么办？<br>答案是：使用元字符<code>|</code> ，它的含义是或。</p>
<p><strong><em>例 匹配多个可选的字符串</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试正则表达式字符：|</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"yes"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"no"</span>));</div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"right"</span>));</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yes matches： yes|no</div><div class="line">no  matches： yes|no</div><div class="line">right   not matches： yes|no</div></pre></td></tr></table></figure></p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组 - ()"></a>分组 - <code>()</code></h3><p>如果你希望表达式由多个子表达式组成，你可以使用<code>()</code>。</p>
<p><strong><em>例 匹配组合字符串</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"ended"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"ending"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"playing"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"played"</span>));</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ended   matches： (play|end)(ing|ed)</div><div class="line">ending  matches： (play|end)(ing|ed)</div><div class="line">playing matches： (play|end)(ing|ed)</div><div class="line">played  matches： (play|end)(ing|ed)</div></pre></td></tr></table></figure></p>
<h3 id="指定单字符有效范围"><a href="#指定单字符有效范围" class="headerlink" title="指定单字符有效范围 - []"></a>指定单字符有效范围 - <code>[]</code></h3><p>前面展示了如何匹配字符串，但是很多时候你需要精确的匹配一个字符，这时可以使用<code>[]</code> 。<br><strong><em>例 字符在指定范围</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试正则表达式字符：[]</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[abc]"</span>, <span class="string">"b"</span>));  <span class="comment">// 字符只能是a、b、c</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-z]"</span>, <span class="string">"m"</span>)); <span class="comment">// 字符只能是a - z</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[A-Z]"</span>, <span class="string">"O"</span>)); <span class="comment">// 字符只能是A - Z</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-zA-Z]"</span>, <span class="string">"K"</span>)); <span class="comment">// 字符只能是a - z和A - Z</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-zA-Z]"</span>, <span class="string">"k"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[0-9]"</span>, <span class="string">"5"</span>)); <span class="comment">// 字符只能是0 - 9</span></div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b   matches： [abc]</div><div class="line">m   matches： [a-z]</div><div class="line">O   matches： [A-Z]</div><div class="line">K   matches： [a-zA-Z]</div><div class="line">k   matches： [a-zA-Z]</div><div class="line">5   matches： [0-9]</div></pre></td></tr></table></figure></p>
<h3 id="指定单字符无效范围"><a href="#指定单字符无效范围" class="headerlink" title="指定单字符无效范围 - [^]"></a>指定单字符无效范围 - <code>[^]</code></h3><p><strong><em>例 字符不能在指定范围</em></strong></p>
<p>如果需要匹配一个字符的逆操作，即字符不能在指定范围，可以使用<code>[^]</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试正则表达式字符：[^]</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^abc]"</span>, <span class="string">"b"</span>)); <span class="comment">// 字符不能是a、b、c</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-z]"</span>, <span class="string">"m"</span>)); <span class="comment">// 字符不能是a - z</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^A-Z]"</span>, <span class="string">"O"</span>)); <span class="comment">// 字符不能是A - Z</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-zA-Z]"</span>, <span class="string">"K"</span>)); <span class="comment">// 字符不能是a - z和A - Z</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-zA-Z]"</span>, <span class="string">"k"</span>));</div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^0-9]"</span>, <span class="string">"5"</span>)); <span class="comment">// 字符不能是0 - 9</span></div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b   not matches： [^abc]</div><div class="line">m   not matches： [^a-z]</div><div class="line">O   not matches： [^A-Z]</div><div class="line">K   not matches： [^a-zA-Z]</div><div class="line">k   not matches： [^a-zA-Z]</div><div class="line">5   not matches： [^0-9]</div></pre></td></tr></table></figure></p>
<h3 id="限制字符数量"><a href="#限制字符数量" class="headerlink" title="限制字符数量 - {}"></a>限制字符数量 - <code>{}</code></h3><p>如果想要控制字符出现的次数，可以使用<code>{}</code>。<br>字符描述{n}n 是一个非负整数。匹配确定的 n 次。{n,}n 是一个非负整数。至少匹配 n 次。{n,m}m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。  </p>
<p><strong><em>例 限制字符出现次数</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &#123;n&#125;: n 是一个非负整数。匹配确定的 n 次。</span></div><div class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"a"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"ap"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"app"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"apppppppppp"</span>);</div><div class="line"></div><div class="line"><span class="comment">// &#123;n,&#125;: n 是一个非负整数。至少匹配 n 次。</span></div><div class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"a"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"ap"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"app"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"apppppppppp"</span>);</div><div class="line"></div><div class="line"><span class="comment">// &#123;n,m&#125;: m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</span></div><div class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"a"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"ap"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"app"</span>);</div><div class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"apppppppppp"</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a   not matches： ap&#123;1&#125;</div><div class="line">ap  matches： ap&#123;1&#125;</div><div class="line">app not matches： ap&#123;1&#125;</div><div class="line">apppppppppp not matches： ap&#123;1&#125;</div><div class="line">a   not matches： ap&#123;1,&#125;</div><div class="line">ap  matches： ap&#123;1,&#125;</div><div class="line">app matches： ap&#123;1,&#125;</div><div class="line">apppppppppp matches： ap&#123;1,&#125;</div><div class="line">a   not matches： ap&#123;2,5&#125;</div><div class="line">ap  not matches： ap&#123;2,5&#125;</div><div class="line">app matches： ap&#123;2,5&#125;</div><div class="line">apppppppppp not matches： ap&#123;2,5&#125;</div></pre></td></tr></table></figure></p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符 - /"></a>转义字符 - <code>/</code></h3><p>如果想要查找元字符本身，你需要使用转义符，使得正则引擎将其视作一个普通字符，而不是一个元字符去处理。  </p>
<ul>
<li><code>*</code> 的转义字符：<code>\*</code></li>
<li><code>+</code> 的转义字符：<code>\+</code></li>
<li><code>?</code> 的转义字符：<code>\?</code></li>
<li><code>^</code> 的转义字符：<code>\^</code></li>
<li><code>$</code> 的转义字符：<code>\$</code></li>
<li><code>.</code> 的转义字符：<code>\.</code><br>如果是转义符<code>\</code>本身，你也需要使用<code>\\</code> 。  </li>
</ul>
<h3 id="指定表达式字符串的开始和结尾-、"><a href="#指定表达式字符串的开始和结尾-、" class="headerlink" title="指定表达式字符串的开始和结尾 - ^、$"></a>指定表达式字符串的开始和结尾 <code>-</code> <code>^</code>、<code>$</code></h3><p>如果希望匹配的字符串必须以特定字符串开头，可以使用<code>^</code> 。<br><strong>注</strong>：请特别留意，这里的<code>^</code> 一定要和 <code>[^]</code> 中的 <code>^</code> 区分。</p>
<p><strong><em>例 限制字符串头部</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Assert.assertTrue(checkMatches(<span class="string">"^app[a-z]&#123;0,&#125;"</span>, <span class="string">"apple"</span>)); <span class="comment">// 字符串必须以app开头</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"^app[a-z]&#123;0,&#125;"</span>, <span class="string">"aplause"</span>));</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apple   matches： ^app[a-z]&#123;0,&#125;</div><div class="line">aplause not matches： ^app[a-z]&#123;0,&#125;</div></pre></td></tr></table></figure></p>
<p>如果希望匹配的字符串必须以特定字符串开头，可以使用<code>$</code> 。<br><strong><em>例 限制字符串尾部</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-z]&#123;0,&#125;ing$"</span>, <span class="string">"playing"</span>)); <span class="comment">// 字符串必须以ing结尾</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[a-z]&#123;0,&#125;ing$"</span>, <span class="string">"long"</span>));</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">playing matches： [a-z]&#123;0,&#125;ing$</div><div class="line">long    not matches： [a-z]&#123;0,&#125;ing$</div></pre></td></tr></table></figure></p>
<h2 id="等价字符"><a href="#等价字符" class="headerlink" title="等价字符"></a>等价字符</h2><p>等价字符，顾名思义，就是对于基本元字符表达的一种简化（等价字符的功能都可以通过基本元字符来实现）。<br>在没有掌握基本元字符之前，可以先不用理会，因为很容易把人绕晕。<br>等价字符的好处在于简化了基本元字符的写法。</p>
<h3 id="表示某一类型字符的等价字符"><a href="#表示某一类型字符的等价字符" class="headerlink" title="表示某一类型字符的等价字符"></a>表示某一类型字符的等价字符</h3><p>下表中的等价字符都表示某一类型的字符。 </p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>匹配除<code>\n</code>之外的任何单个字符。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配一个数字字符。等价于<code>[0-9]</code>。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字字符。等价于<code>[^0-9]</code>。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配包括下划线的任何单词字符。类似但不等价于<code>[A-Za-z0-9_]</code>，这里的单词字符指的是Unicode字符集。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任何非单词字符。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于<code>[ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何可见字符。等价于<code>[ \f\n\r\t\v]</code>。</td>
</tr>
</tbody>
</table>
<p><strong><em>案例 基本等价字符的用法</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配除“\n”之外的任何单个字符</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">".&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">".&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"."</span>, <span class="string">"\n"</span>));</div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"[^\n]"</span>, <span class="string">"\n"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 匹配一个数字字符。等价于[0-9]</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"\\d&#123;1,&#125;"</span>, <span class="string">"0123456789"</span>));</div><div class="line"><span class="comment">// 匹配一个非数字字符。等价于[^0-9]</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"\\D&#123;1,&#125;"</span>, <span class="string">"0123456789"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是Unicode字符集</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"\\w&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"\\w&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</div><div class="line"><span class="comment">// 匹配任何非单词字符</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"\\W&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"\\W&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]</span></div><div class="line">Assert.assertTrue(checkMatches(<span class="string">"\\s&#123;1,&#125;"</span>, <span class="string">" \f\r\n\t"</span>));</div><div class="line"><span class="comment">// 匹配任何可见字符。等价于[^ \f\n\r\t\v]</span></div><div class="line">Assert.assertFalse(checkMatches(<span class="string">"\\S&#123;1,&#125;"</span>, <span class="string">" \f\r\n\t"</span>));</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_ matches： .&#123;1,&#125;</div><div class="line">~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\  matches： .&#123;1,&#125;</div><div class="line">\n  not matches： .</div><div class="line">\n  not matches： [^\n]</div><div class="line">0123456789  matches： \\d&#123;1,&#125;</div><div class="line">0123456789  not matches： \\D&#123;1,&#125;</div><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_ matches： \\w&#123;1,&#125;</div><div class="line">~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\  not matches： \\w&#123;1,&#125;</div><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_ not matches： \\W&#123;1,&#125;</div><div class="line">~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\  matches： \\W&#123;1,&#125;</div><div class="line"> \f\r\n\t   matches： \\s&#123;1,&#125;</div><div class="line"> \f\r\n\t   not matches： \\S&#123;1,&#125;</div></pre></td></tr></table></figure></p>
<h3 id="限制字符数量的等价字符"><a href="#限制字符数量的等价字符" class="headerlink" title="限制字符数量的等价字符"></a>限制字符数量的等价字符</h3><p>在基本元字符章节中，已经介绍了限制字符数量的基本元字符 - <code>{}</code> 。<br>此外，还有 <code>*</code>、<code>+</code>、<code>?</code> 这个三个为了简化写法而出现的等价字符，我们来认识一下。<br>字符描述<code>*</code>匹配前面的子表达式零次或多次。等价于<code>{0,}</code>。<code>+</code>匹配前面的子表达式一次或多次。等价于<code>{1,}</code>。<code>?</code>匹配前面的子表达式零次或一次。等价于<code>{0,1}</code>。  </p>
<p><strong><em>案例 限制字符数量的等价字符</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *: 匹配前面的子表达式零次或多次。* 等价于&#123;0,&#125;。</span></div><div class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"a"</span>);</div><div class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"ap"</span>);</div><div class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"app"</span>);</div><div class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"apppppppppp"</span>);</div><div class="line"></div><div class="line"><span class="comment">// +: 匹配前面的子表达式一次或多次。+ 等价于 &#123;1,&#125;。</span></div><div class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"a"</span>);</div><div class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"ap"</span>);</div><div class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"app"</span>);</div><div class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"apppppppppp"</span>);</div><div class="line"></div><div class="line"><span class="comment">// ?: 匹配前面的子表达式零次或一次。? 等价于 &#123;0,1&#125;。</span></div><div class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"a"</span>);</div><div class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"ap"</span>);</div><div class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"app"</span>);</div><div class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"apppppppppp"</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a   matches： ap*</div><div class="line">ap  matches： ap*</div><div class="line">app matches： ap*</div><div class="line">apppppppppp matches： ap*</div><div class="line">a   not matches： ap+</div><div class="line">ap  matches： ap+</div><div class="line">app matches： ap+</div><div class="line">apppppppppp matches： ap+</div><div class="line">a   matches： ap?</div><div class="line">ap  matches： ap?</div><div class="line">app not matches： ap?</div><div class="line">apppppppppp not matches： ap?</div></pre></td></tr></table></figure></p>
<h2 id="元字符优先级顺序"><a href="#元字符优先级顺序" class="headerlink" title="元字符优先级顺序"></a>元字符优先级顺序</h2><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。<br>下表从最高到最低说明了各种正则表达式运算符的优先级顺序： </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>转义符</td>
</tr>
<tr>
<td><code>()</code>, <code>(?:)</code>, <code>(?=)</code>, <code>[]</code></td>
<td>括号和中括号</td>
</tr>
<tr>
<td><code>*</code>,<code>+</code>, <code>?</code>, <code>{n}</code>, <code>{n,}</code>, <code>{n,m}</code></td>
<td>限定符</td>
</tr>
<tr>
<td><code>^</code>, <code>$</code>, <code>*</code>任何元字符、任何字符<code>*</code></td>
<td>定位点和序列</td>
</tr>
<tr>
<td><code>\</code></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>字符具有高于替换运算符的优先级，使得<code>m|food</code>匹配<code>m</code>或<code>food</code>。若要匹配<code>mood</code>或<code>food</code>，请使用括号创建子表达式，从而产生<code>(m|f)ood</code>。</p>
<h1 id="分组构造"><a href="#分组构造" class="headerlink" title="分组构造"></a>分组构造</h1><p>在基本元字符章节，提到了 <code>()</code> 字符可以用来对表达式分组。实际上分组还有更多复杂的用法。<br>所谓分组构造，是用来描述正则表达式的子表达式，用于捕获字符串中的子字符串。  </p>
<h2 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h2><p>下表为分组构造中的捕获和非捕获分类。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>捕获或非捕获</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的反向引用</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>零宽度正预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>零宽度负预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>零宽度正回顾后发断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>零宽度负回顾后发断言</td>
<td>非捕获</td>
</tr>
</tbody>
</table>
<p><strong><em>注：</em></strong>Java正则引擎不支持平衡组。</p>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><h3 id="带编号的反向引用"><a href="#带编号的反向引用" class="headerlink" title="带编号的反向引用"></a>带编号的反向引用</h3><p>带编号的反向引用使用以下语法：<code>\number</code><br>其中<code>number</code>是正则表达式中捕获组的序号位置。 例如，<code>\4</code> 匹配第四个捕获组的内容。 如果正则表达式模式中未定义<code>number</code>，则将发生分析错误</p>
<p><strong><em>例 匹配重复的单词和紧随每个重复的单词的单词(不命名子表达式)</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// (\w+)\s\1\W(\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"(\\w+)\\s\\1\\W(\\w+)"</span>,</div><div class="line">        <span class="string">"He said that that was the the correct answer."</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">regex = (\w+)\s\1\W(\w+), content: He said that that was the the correct answer.</div><div class="line">[1th] start: 8, end: 21, group: that that was</div><div class="line">[2th] start: 22, end: 37, group: the the correct</div></pre></td></tr></table></figure></p>
<p><strong><em>说明</em></strong></p>
<ul>
<li><code>(\w+)</code>: 匹配一个或多个单词字符。</li>
<li><code>\s</code>: 与空白字符匹配。</li>
<li><code>\1</code>: 匹配第一个组，即<code>(\w+)</code>。</li>
<li><code>\W</code>: 匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</li>
<li><h3 id="命名的反向引用"><a href="#命名的反向引用" class="headerlink" title="命名的反向引用"></a>命名的反向引用</h3>命名后向引用通过使用下面的语法进行定义：<code>\k&lt;name&gt;</code><br><strong><em>例 匹配重复的单词和紧随每个重复的单词的单词(命名子表达式)</em></strong><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;duplicateWord&gt;\\w+)\\s\\k&lt;duplicateWord&gt;\\W(?&lt;nextWord&gt;\\w+)"</span>,</div><div class="line">        <span class="string">"He said that that was the the correct answer."</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">regex = (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+), content: He said that that was the the correct answer.</div><div class="line">[1th] start: 8, end: 21, group: that that was</div><div class="line">[2th] start: 22, end: 37, group: the the correct</div></pre></td></tr></table></figure></p>
<p><strong><em>说明</em></strong></p>
<ul>
<li><code>(?\w+)</code>: 匹配一个或多个单词字符。 命名此捕获组 duplicateWord。</li>
<li><code>\s</code>: 与空白字符匹配。</li>
<li><code>\k</code>: 匹配名为 duplicateWord 的捕获的组。</li>
<li><code>\W</code>: 匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</li>
<li><code>(?\w+)</code>: 匹配一个或多个单词字符。 命名此捕获组 nextWord。</li>
</ul>
<h2 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h2><p><code>(?:exp)</code> 表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。<br><strong><em>例 匹配以.结束的语句。</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配由句号终止的语句。</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"(?:\\b(?:\\w+)\\W*)+\\."</span>, <span class="string">"This is a short sentence. Never end"</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">regex = (?:\b(?:\w+)\W*)+\., content: This is a short sentence. Never end</div><div class="line">[1th] start: 0, end: 25, group: This is a short sentence.</div></pre></td></tr></table></figure></p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像<code>\b</code>,<code>^</code>,<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。  </p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(?=exp)</code></td>
<td>匹配<code>exp</code>前面的位置</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配<code>exp</code>后面的位置</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是<code>exp</code>的位置</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是exp的位置</td>
</tr>
</tbody>
</table>
<h3 id="匹配exp前面的位置"><a href="#匹配exp前面的位置" class="headerlink" title="匹配exp前面的位置"></a>匹配exp前面的位置</h3><p><code>(?=exp)</code> 表示输入字符串必须匹配子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// \b\w+(?=\sis\b) 表示要捕获is之前的单词</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The dog is a Malamute."</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertFalse(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The island has beautiful birds."</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertFalse(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The pitch missed home plate."</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"Sunday is a weekend day."</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">regex = \b\w+(?=\sis\b), content: The dog is a Malamute.</div><div class="line">[1th] start: 4, end: 7, group: dog</div><div class="line">regex = \b\w+(?=\sis\b), content: The island has beautiful birds.</div><div class="line">not found</div><div class="line">regex = \b\w+(?=\sis\b), content: The pitch missed home plate.</div><div class="line">not found</div><div class="line">regex = \b\w+(?=\sis\b), content: Sunday is a weekend day.</div><div class="line">[1th] start: 0, end: 6, group: Sunday</div></pre></td></tr></table></figure></p>
<p><strong><em>说明</em></strong></p>
<ul>
<li><code>\b</code>: 在单词边界处开始匹配。</li>
<li><code>\w+</code>: 匹配一个或多个单词字符。</li>
<li><code>(?=\sis\b)</code>: 确定单词字符是否后接空白字符和字符串<code>is</code>，其在单词边界处结束。 如果如此，则匹配成功。</li>
</ul>
<h3 id="匹配exp后面的位置"><a href="#匹配exp后面的位置" class="headerlink" title="匹配exp后面的位置"></a>匹配exp后面的位置</h3><p><code>(?&lt;=exp)</code> 表示子表达式不得在输入字符串当前位置左侧出现，尽管子表达式未包含在匹配结果中。零宽度正回顾后发断言不会回溯。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// (?&lt;=\b20)\d&#123;2&#125;\b 表示要捕获以20开头的数字的后面部分</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;=\\b20)\\d&#123;2&#125;\\b"</span>, <span class="string">"2010 1999 1861 2140 2009"</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">regex = (?&lt;=\b20)\d&#123;2&#125;\b, content: 2010 1999 1861 2140 2009</div><div class="line">[1th] start: 2, end: 4, group: 10</div><div class="line">[2th] start: 22, end: 24, group: 09</div></pre></td></tr></table></figure></p>
<p><strong><em>说明</em></strong></p>
<ul>
<li><code>\d{2}</code>: 匹配两个十进制数字。</li>
<li><code>{?&lt;=\b20)</code>: 如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。</li>
<li><code>\b</code>: 在单词边界处结束匹配。</li>
</ul>
<h3 id="匹配后面跟的不是exp的位置"><a href="#匹配后面跟的不是exp的位置" class="headerlink" title="匹配后面跟的不是exp的位置"></a>匹配后面跟的不是exp的位置</h3><p><code>(?!exp)</code> 表示输入字符串不得匹配子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。<br><strong><em>例 捕获未以“un”开头的单词</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// \b(?!un)\w+\b 表示要捕获未以“un”开头的单词</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"\\b(?!un)\\w+\\b"</span>, <span class="string">"unite one unethical ethics use untie ultimate"</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">regex = \b(?!un)\w+\b, content: unite one unethical ethics use untie ultimate</div><div class="line">[1th] start: 6, end: 9, group: one</div><div class="line">[2th] start: 20, end: 26, group: ethics</div><div class="line">[3th] start: 27, end: 30, group: use</div><div class="line">[4th] start: 37, end: 45, group: ultimate</div></pre></td></tr></table></figure></p>
<p><strong><em>说明</em></strong></p>
<ul>
<li><code>\b</code>: 在单词边界处开始匹配。</li>
<li><code>(?!un)</code>: 确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。</li>
<li><code>\w+</code>: 匹配一个或多个单词字符。</li>
<li><code>\b</code>: 在单词边界处结束匹配。</li>
</ul>
<h3 id="匹配前面不是exp的位置"><a href="#匹配前面不是exp的位置" class="headerlink" title="匹配前面不是exp的位置"></a>匹配前面不是exp的位置</h3><p><code>(?&lt;!exp)</code> 表示子表达式不得在输入字符串当前位置的左侧出现。 但是，任何不匹配子表达式 的子字符串不包含在匹配结果中。<br><strong><em>例 捕获任意工作日</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b 表示要捕获任意工作日（即周一到周五）</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Monday February 1, 2010"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Wednesday February 3, 2010"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertFalse(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Saturday February 6, 2010"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertFalse(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Sunday February 7, 2010"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Monday, February 8, 2010"</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Monday February 1, 2010</div><div class="line">[1th] start: 7, end: 23, group: February 1, 2010</div><div class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Wednesday February 3, 2010</div><div class="line">[1th] start: 10, end: 26, group: February 3, 2010</div><div class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Saturday February 6, 2010</div><div class="line">not found</div><div class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Sunday February 7, 2010</div><div class="line">not found</div><div class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Monday, February 8, 2010</div><div class="line">[1th] start: 8, end: 24, group: February 8, 2010</div></pre></td></tr></table></figure></p>
<h1 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h1><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。<br>以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串。如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code>。这被称为贪婪匹配。<br>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。  </p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,m}?</code></td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,}?</code></td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<p><strong><em>例 Java正则中贪婪与懒惰的示例</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 贪婪匹配</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"a\\w*b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 懒惰匹配</span></div><div class="line">Assert.assertTrue(findAll(<span class="string">"a\\w*?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"a\\w+?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"a\\w??b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"a\\w&#123;0,4&#125;?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</div><div class="line">Assert.assertTrue(findAll(<span class="string">"a\\w&#123;3,&#125;?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p><strong><em>输出</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">regex = a\w*b, content: abaabaaabaaaab</div><div class="line">[1th] start: 0, end: 14, group: abaabaaabaaaab</div><div class="line">regex = a\w*?b, content: abaabaaabaaaab</div><div class="line">[1th] start: 0, end: 2, group: ab</div><div class="line">[2th] start: 2, end: 5, group: aab</div><div class="line">[3th] start: 5, end: 9, group: aaab</div><div class="line">[4th] start: 9, end: 14, group: aaaab</div><div class="line">regex = a\w+?b, content: abaabaaabaaaab</div><div class="line">[1th] start: 0, end: 5, group: abaab</div><div class="line">[2th] start: 5, end: 9, group: aaab</div><div class="line">[3th] start: 9, end: 14, group: aaaab</div><div class="line">regex = a\w??b, content: abaabaaabaaaab</div><div class="line">[1th] start: 0, end: 2, group: ab</div><div class="line">[2th] start: 2, end: 5, group: aab</div><div class="line">[3th] start: 6, end: 9, group: aab</div><div class="line">[4th] start: 11, end: 14, group: aab</div><div class="line">regex = a\w&#123;0,4&#125;?b, content: abaabaaabaaaab</div><div class="line">[1th] start: 0, end: 2, group: ab</div><div class="line">[2th] start: 2, end: 5, group: aab</div><div class="line">[3th] start: 5, end: 9, group: aaab</div><div class="line">[4th] start: 9, end: 14, group: aaaab</div><div class="line">regex = a\w&#123;3,&#125;?b, content: abaabaaabaaaab</div><div class="line">[1th] start: 0, end: 5, group: abaab</div><div class="line">[2th] start: 5, end: 14, group: aaabaaaab</div></pre></td></tr></table></figure></p>
<p><strong><em>说明</em></strong><br>本例中代码展示的是使用不同贪婪或懒惰策略去查找字符串<code>abaabaaabaaaab</code> 中匹配<strong>以<code>a</code>开头，以<code>b</code>结尾的所有子字符串</strong>。<br>请从输出结果中，细细体味使用不同的贪婪或懒惰策略，对于匹配子字符串有什么影响。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="匹配正则字符串的方法"><a href="#匹配正则字符串的方法" class="headerlink" title="匹配正则字符串的方法"></a>匹配正则字符串的方法</h2><p>由于正则表达式中很多元字符本身就是转义字符，在Java字符串的规则中不会被显示出来。<br>为此，可以使用一个工具类<code>org.apache.commons.lang3.StringEscapeUtils</code>来做特殊处理，使得转义字符可以打印。这个工具类提供的都是静态方法，从方法命名大致也可以猜出用法，这里不多做说明。<br>如果你了解maven，可以直接引入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>本文为了展示正则匹配规则用到的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMatches</span><span class="params">(String regex, String content)</span> </span>&#123;</div><div class="line">    Pattern p = Pattern.compile(regex);</div><div class="line">    Matcher m = p.matcher(content);</div><div class="line">    <span class="keyword">boolean</span> flag = m.matches();</div><div class="line">    <span class="keyword">if</span> (m.matches()) &#123;</div><div class="line">        System.out.println(StringEscapeUtils.escapeJava(content) + <span class="string">"\tmatches： "</span> + StringEscapeUtils.escapeJava(regex));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(StringEscapeUtils.escapeJava(content) + <span class="string">"\tnot matches： "</span> + StringEscapeUtils.escapeJava(regex));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> flag;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findAll</span><span class="params">(String regex, String content)</span> </span>&#123;</div><div class="line">    Pattern p = Pattern.compile(regex);</div><div class="line">    Matcher m = p.matcher(content);</div><div class="line">    System.out.println(<span class="string">"regex = "</span> + regex + <span class="string">", content: "</span> + content);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (m.find()) &#123;</div><div class="line">        count++;</div><div class="line">        System.out.println(<span class="string">"["</span> + count + <span class="string">"th] "</span> + <span class="string">"start: "</span> + m.start() + <span class="string">", end: "</span> + m.end()</div><div class="line">                + <span class="string">", group: "</span> + m.group());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</div><div class="line">        System.out.println(<span class="string">"not found"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="速查元字符字典"><a href="#速查元字符字典" class="headerlink" title="速查元字符字典"></a>速查元字符字典</h2><p>为了方便快查正则的元字符含义，在本节根据元字符的功能集中罗列正则的各种元字符。</p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配。</td>
</tr>
</tbody>
</table>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\cx</code></td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
<h3 id="分组-1"><a href="#分组-1" class="headerlink" title="分组"></a>分组</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式。()中的内容就是子表达式。</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的子表达式（反向引用）。</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组，表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>匹配exp前面的位置。</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配exp后面的位置。</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是exp的位置。</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是exp的位置。</td>
</tr>
</tbody>
</table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\’ 匹配 “”，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td><code>\&#124;</code></td>
<td>指明两项之间的一个选择。</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配方括号范围内的任意一个字符。形式如：[xyz]、[^xyz]、[a-z]、[^a-z]、[x,y,z]</td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a><br><a href="https://msdn.microsoft.com/zh-cn/library/d9eze55x(v=vs.80" target="_blank" rel="external">msdn 正则表达式教程</a>.aspx)<br>作者：静默虚空<br>出处：<a href="http://www.cnblogs.com/jingmoxukong/" target="_blank" rel="external">http://www.cnblogs.com/jingmoxukong/</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/转载/" rel="tag"># 转载</a>
          
            <a href="/tags/正则/" rel="tag"># 正则</a>
          
            <a href="/tags/正则表达式/" rel="tag"># 正则表达式</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/20170421/regular_java_3/" rel="next" title="Java正则速成秘籍（三）之见招拆招篇">
                <i class="fa fa-chevron-left"></i> Java正则速成秘籍（三）之见招拆招篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/20170421/regular_java_1/" rel="prev" title="Java正则速成秘籍（一）之招式篇">
                Java正则速成秘籍（一）之招式篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/face.jpg"
               alt="曙光" />
          <p class="site-author-name" itemprop="name">曙光</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a rel="external nofollow" href="https://github.com/zhaoshg" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a rel="external nofollow" href="http://www.nongrj.com/" title="农仁街" target="_blank">农仁街</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#导读"><span class="nav-number">1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元字符"><span class="nav-number">3.</span> <span class="nav-text">元字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本元字符"><span class="nav-number">3.1.</span> <span class="nav-text">基本元字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多选"><span class="nav-number">3.1.1.</span> <span class="nav-text">多选 - |</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组"><span class="nav-number">3.1.2.</span> <span class="nav-text">分组 - ()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定单字符有效范围"><span class="nav-number">3.1.3.</span> <span class="nav-text">指定单字符有效范围 - []</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定单字符无效范围"><span class="nav-number">3.1.4.</span> <span class="nav-text">指定单字符无效范围 - [^]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制字符数量"><span class="nav-number">3.1.5.</span> <span class="nav-text">限制字符数量 - {}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转义字符"><span class="nav-number">3.1.6.</span> <span class="nav-text">转义字符 - /</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定表达式字符串的开始和结尾-、"><span class="nav-number">3.1.7.</span> <span class="nav-text">指定表达式字符串的开始和结尾 - ^、$</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等价字符"><span class="nav-number">3.2.</span> <span class="nav-text">等价字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#表示某一类型字符的等价字符"><span class="nav-number">3.2.1.</span> <span class="nav-text">表示某一类型字符的等价字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制字符数量的等价字符"><span class="nav-number">3.2.2.</span> <span class="nav-text">限制字符数量的等价字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元字符优先级顺序"><span class="nav-number">3.3.</span> <span class="nav-text">元字符优先级顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分组构造"><span class="nav-number">4.</span> <span class="nav-text">分组构造</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获与非捕获"><span class="nav-number">4.1.</span> <span class="nav-text">捕获与非捕获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反向引用"><span class="nav-number">4.2.</span> <span class="nav-text">反向引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#带编号的反向引用"><span class="nav-number">4.2.1.</span> <span class="nav-text">带编号的反向引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名的反向引用"><span class="nav-number">4.2.2.</span> <span class="nav-text">命名的反向引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非捕获组"><span class="nav-number">4.3.</span> <span class="nav-text">非捕获组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#零宽断言"><span class="nav-number">4.4.</span> <span class="nav-text">零宽断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配exp前面的位置"><span class="nav-number">4.4.1.</span> <span class="nav-text">匹配exp前面的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配exp后面的位置"><span class="nav-number">4.4.2.</span> <span class="nav-text">匹配exp后面的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配后面跟的不是exp的位置"><span class="nav-number">4.4.3.</span> <span class="nav-text">匹配后面跟的不是exp的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配前面不是exp的位置"><span class="nav-number">4.4.4.</span> <span class="nav-text">匹配前面不是exp的位置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#贪婪与懒惰"><span class="nav-number">5.</span> <span class="nav-text">贪婪与懒惰</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录"><span class="nav-number">6.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配正则字符串的方法"><span class="nav-number">6.1.</span> <span class="nav-text">匹配正则字符串的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#速查元字符字典"><span class="nav-number">6.2.</span> <span class="nav-text">速查元字符字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#限定符"><span class="nav-number">6.2.1.</span> <span class="nav-text">限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定位符"><span class="nav-number">6.2.2.</span> <span class="nav-text">定位符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非打印字符"><span class="nav-number">6.2.3.</span> <span class="nav-text">非打印字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组-1"><span class="nav-number">6.2.4.</span> <span class="nav-text">分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊符号"><span class="nav-number">6.2.5.</span> <span class="nav-text">特殊符号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" align="center">
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">曙光</span>
</div>
<!--

<div class="powered-by">
  由 <a rel="external nofollow" class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a rel="external nofollow" class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

-->


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "66baac132d9b4e38acd9a0a664710c6f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("HofnnMS813HyOHPUrN3wmNkQ-gzGzoHsz", "mL2pwohDw3hUOwrR9jaBs553");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  


  

  

</body>
</html>
